/*
 * (C) Copyright 2011 - MFG <http://www.marketforecastgroup.com/>
 * All rights reserved. This program and the accompanying materials
 * are proprietary to Giulio Rugarli.
 *
 * $Id: $
 */
/**
 * @author <a href="mailto:gardero@gmail.com">Enrique Matos Alfonso</a>, MFG
 *
 * @version $Revision: $ $Date: $
 */

package com.mfg.strategy.automatic.triggers;

import java.awt.Color;

import com.mfg.interfaces.indicator.IIndicator;
import com.mfg.interfaces.indicator.Pivot;
import com.mfg.utils.MathUtils;
import com.mfg.utils.ui.HtmlUtils;
import com.mfg.widget.priv.MinMaxBoundRanges;
import com.mfg.widget.priv.TRIGGER_TYPE;

public class RatioTrigger extends ValueScaleSpecificTrigger {

	/**
     * 
     */
	private static final long serialVersionUID = -8131815136083530217L;
	/**
	 * the lower bounds for the swing ratios.
	 */
	protected double[] lowerBounds;
	/**
	 * the upper bounds for the swing ratios.
	 */
	protected double[] upperBounds;
	protected double[] infiniteBounds;
	/**
	 * the dimensions of this trigger
	 */
	protected int dimensions;

	@Override
	protected boolean internalIsActive() {
		if (!fWidget.isLevelInformationPresent(fWidgetScale))
			return false;
		if (fWidget.isThereANewPivot(fWidgetScale)
				&& (fWidget.getLastPivot(0, fWidgetScale).fLinearSwing != Integer.MAX_VALUE)) {
			_shift_swings(fWidget, fWidgetScale);
			logSwings("shift", _swings);
		}
		return process();
	}

	public RatioTrigger(TRIGGER_TYPE aType) {
		super(aType);
		dimensions = 0;
		lowerBounds = new double[0];
		upperBounds = new double[0];
		infiniteBounds = new double[0];
	}

	@Override
	public void init(IIndicator aWidget) {
		super.init(aWidget);
		int dim = dimensions;
		final int index = aWidget.getCurrentPivotsCount(fWidgetScale);
		int top = Math.min(index - 1, dim);
		initTempArrays(dimensions, getBucketDimensions(dimensions));
		for (int i = top - 1; i >= 0; i--) {
			_shift_swings(aWidget.getLastPivot(-i, fWidgetScale));
		}
		logSwings("Init", _swings);
		// System.out.println("Index ---> "+index);
	}

	public RatioTrigger() {
		super(TRIGGER_TYPE.PRICE);
		dimensions = 0;
		lowerBounds = new double[0];
		upperBounds = new double[0];
		infiniteBounds = new double[0];
	}

	/**
	 * These are the swings generated by the zz algorithm. They are stored here
	 * for convenience
	 */
	private double[] _swings;
	private double[] _slope;
	private double[] _timeIntervals;
	private double[] _2Dswings;
	private Pivot[] _pivots;

	/**
	 * This is only a temporary vector. It is used to store the swing ratios.
	 */
	private volatile double[] _swingsRatios;
	/**
	 * this is for timeRatios just as price ratios
	 */
	private volatile double[] _timeRatios;
	/**
	 * and this other one considers modules vector ratios
	 */
	private volatile double[] _vectorRatios;

	protected boolean oldresult = false;
	protected boolean recompute = true;

	// private int minPivotsToRead;

	/**
	 * @return true if we have the minimum number of pivots.
	 */
	protected boolean _reachedMinimumSwings() {
		if (isWorkingRatiosFilter() && _swings[0] == 0) {
			return false;
		}
		return true;// minPivotsToRead == 0;
	}

	public boolean isWorkingRatiosFilter() {
		return fValueType != TRIGGER_TYPE.NONE && dimensions > 0 && isEnabled();
	}

	/**
	 * This function simply checks if the pattern is present, after receiving a
	 * new swing
	 * 
	 * @return true if the pattern is present
	 */
	protected boolean _is_pattern_present() {
		if (isWorkingRatiosFilter()) {
			double[] temp = fValueType.giveMeArrayToEval(_swingsRatios,
					_timeRatios, _vectorRatios);
			logSwings("Check", _swings);
			logSwings("Check", temp);
			// System.out.println(Arrays.toString(temp));
			for (int i = 0; i < lowerBounds.length; ++i) {
				if (temp[i] <= lowerBounds[i]) {
					return false;
				}
				if (temp[i] > upperBounds[i]
						&& upperBounds[i] < infiniteBounds[i]) {
					return false;
				}
			}
		}
		return true;
	}

	/**
	 * @param pre
	 * @param v
	 */
	private void logSwings(String pre, double v[]) {
		// if (_log.isDebugEnabled()) {
		// _log.debug(pre + " sw=" + Arrays.toString(v) + "]");
		// }
	}

	// private static Logger _log = Logger.getLogger(RatioTrigger.class);

	public boolean process() {
		if (recompute) {
			oldresult = false;
			recompute = false;
			setOldinternalIsActive(false);
			if (!_reachedMinimumSwings()) {
				return false;
			}
			// then I have to check the relationship between the swings
			if (!_is_pattern_present()) {
				// System.out.println("trigger failed"+lastPivot.toString());
				return false; // nothing to do.
			}
			oldresult = true;
		}
		return oldresult;
	}

	/**
	 * This function shifts the swings and computes the new swing ratios
	 * 
	 * @param aWidget
	 *            the Indicator
	 * @param aWidgetScale
	 *            the scale we are using in this trigger.
	 */
	protected void _shift_swings(IIndicator aWidget, int aWidgetScale) {
		_shift_swings(aWidget.getLastPivot(0, aWidgetScale));
	}

	protected void _shift_swings(Pivot p) {
		if (_pivots[dimensions - 1] != null
				&& p.fConfirmTime == _pivots[dimensions - 1].fConfirmTime)
			return;
		processPivot(p);
		if (!isWorkingRatiosFilter()) {
			return;
		}
		shiftRatios();
	}

	private void shiftRatios() {
		int index = _swingsRatios.length - 2;
		int k = dimensions - 1;
		int p = 0;
		double pivot = _swings[k];
		double tInterval = _timeIntervals[k];
		double mod = _2Dswings[k];

		double price0 = Math.abs(_pivots[k].fPivotPrice
				- _pivots[k].fConfirmPrice);
		_swingsRatios[0] = price0 / pivot;
		long time0 = _pivots[k].fConfirmTime - _pivots[k].fPivotTime;
		_timeRatios[0] = -time0 / tInterval;
		Pivot piv = _pivots[k];
		if (k > 1 && _pivots[k - 1] != null)
			piv = _pivots[k - 1];
		double price = TRIGGER_TYPE.PRICE.getSwingValue(piv);
		double time = TRIGGER_TYPE.TIME.getSwingValue(piv);
		double f = (price != 0) ? (price / time) : 1;
		double vect = MathUtils.modulus(price0, f * time0);
		_vectorRatios[0] = vect / mod;

		for (; k >= 1; k--) {
			for (int i = 1; i < k; i++) {
				_swingsRatios[index + 1] = _swingsRatios[index + 1 - k];
				_timeRatios[index + 1] = _timeRatios[index + 1 - k];
				_vectorRatios[index + 1] = _vectorRatios[index + 1 - k];
				index--;
			}
			p = (dimensions - 1) - k;
			if (_swings[p] > 0) {
				_swingsRatios[index + 1] = pivot / _swings[p];
				_timeRatios[index + 1] = tInterval / _timeIntervals[p];
				_vectorRatios[index + 1] = mod / _2Dswings[p];
			}
			index--;
		}
	}

	private void processPivot(Pivot newPivot) {
		recompute = true;
		// if (minPivotsToRead > 0) {
		// minPivotsToRead--;
		// }

		if (!isWorkingRatiosFilter()) {
			return;
		}
		for (int i = 0; i < _swings.length - 1; ++i) {
			_swings[i] = _swings[i + 1];
			_pivots[i] = _pivots[i + 1];
			_2Dswings[i] = _2Dswings[i + 1];
			_timeIntervals[i] = _timeIntervals[i + 1];
			_slope[i] = _slope[i + 1];
		}
		int lind = _swings.length - 1;
		_swings[lind] = TRIGGER_TYPE.PRICE.getSwingValue(newPivot);
		_pivots[lind] = newPivot;
		_timeIntervals[lind] = TRIGGER_TYPE.TIME.getSwingValue(newPivot);
		_2Dswings[lind] = TRIGGER_TYPE.VECTORIAL.getSwingValue(newPivot);
		_slope[lind] = _swings[lind] / _timeIntervals[lind];
	}

	/*
	 * private void processPivot(IIndicator widget, int scale) { Pivot newPivot
	 * = widget.getLastPivot(0, scale); recompute = true; // if (minPivotsToRead
	 * > 0) { // minPivotsToRead--; // }
	 * 
	 * if (!isWorkingRatiosFilter()) { return; } for (int i = 0; i <
	 * _swings.length - 1; ++i) { _swings[i] = _swings[i + 1]; _pivots[i] =
	 * _pivots[i + 1]; _2Dswings[i] = _2Dswings[i + 1]; _timeIntervals[i] =
	 * _timeIntervals[i + 1]; _slope[i] = _slope[i + 1]; } int lind =
	 * _swings.length - 1; _swings[lind] =
	 * TRIGGER_TYPE.PRICE.getSwingValue(widget, scale, -1); _pivots[lind] =
	 * newPivot; _timeIntervals[lind] = TRIGGER_TYPE.TIME.getSwingValue(widget,
	 * scale, -1); _2Dswings[lind] =
	 * TRIGGER_TYPE.VECTORIAL.getSwingValue(widget, scale, -1); _slope[lind] =
	 * _swings[lind] / _timeIntervals[lind]; }
	 */

	/**
	 * This method updates the array dimensions.
	 * 
	 * @param numRatios
	 *            The number of ratios in the pattern This is equal to one less
	 *            the number of swings
	 * @return the number of ratios
	 */
	private void updateDimensions(int numDimensions, int olddim, boolean force) {
		if (fValueType == null && !isWorkingRatiosFilter()) {
			return;
		}
		int newNumRatios = getBucketDimensions(numDimensions);
		int oldNumRatios = (lowerBounds == null) ? TRIGGER_TYPE
				.giveMeBucketDims(olddim) : lowerBounds.length;
		// // If the requested dimension is already present... do nothing
		if (lowerBounds == null || newNumRatios != oldNumRatios || force) {
			double[] newlowerBounds = new double[newNumRatios];
			double[] newupperBounds = new double[newNumRatios];
			double[] newinfiniteBounds = new double[newNumRatios];
			if (lowerBounds != null && !force) {
				System.arraycopy(lowerBounds, 0, newlowerBounds, 0,
						Math.min(oldNumRatios, newNumRatios));
				System.arraycopy(upperBounds, 0, newupperBounds, 0,
						Math.min(oldNumRatios, newNumRatios));
				System.arraycopy(infiniteBounds, 0, newinfiniteBounds, 0,
						Math.min(oldNumRatios, newNumRatios));
				for (int i = oldNumRatios; i < newNumRatios; ++i) {
					// the _number_of_ratio_intervals is excluded.
					// System.out.println("Updating bounds");
					double lowerBucket = 0;
					newlowerBounds[i] = lowerBucket;
					double upperBucket = 1;
					newupperBounds[i] = upperBucket;
					newinfiniteBounds[i] = 10;
				}
			} else
				for (int i = 0; i < newNumRatios; ++i) {
					// the _number_of_ratio_intervals is excluded.
					// System.out.println("Updating bounds");
					double lowerBucket = 0;
					newlowerBounds[i] = lowerBucket;
					double upperBucket = 1;
					newupperBounds[i] = upperBucket;
					newinfiniteBounds[i] = 10;
				}
			lowerBounds = newlowerBounds;
			upperBounds = newupperBounds;
			infiniteBounds = newinfiniteBounds;
		}
		initTempArrays(numDimensions, newNumRatios);

	}

	private static int getBucketDimensions(int numDimensions) {
		return 1 + (numDimensions * (numDimensions - 1)) / 2;
	}

	private void initTempArrays(int numDimensions, int newNumRatios) {
		// then the swings and the swing ratios.
		_swingsRatios = new double[newNumRatios];
		_timeRatios = new double[newNumRatios];
		_vectorRatios = new double[newNumRatios];
		// the swings are one more the dimensions.
		_swings = new double[numDimensions];
		_pivots = new Pivot[numDimensions];
		_timeIntervals = new double[numDimensions];
		_2Dswings = new double[numDimensions];
		_slope = new double[numDimensions];
	}

	public void begin() {
		updateDimensions(dimensions, dimensions, false);
		oldresult = false;
		recompute = true;
		if (isWorkingRatiosFilter()) {
			for (int i = 0; i < _swings.length; ++i) {
				_swings[i] = 0;
				_pivots[i] = null;
				_timeIntervals[i] = 0;
				_2Dswings[i] = 0;
			}
		}
	}

	public void setDimensions(int aDimensions) {
		int old = this.dimensions;
		this.dimensions = aDimensions;
		updateDimensions(aDimensions, old, false);
	}

	/**
	 * @return the lowerBounds
	 */
	// @EditorFactory(BoundsRatioFieldEditorFactory.class)
	// @JSON(index = 400)
	public double[] getLowerBounds() {
		return lowerBounds;
	}

	/**
	 * @param aLowerBounds
	 *            the lowerBounds to set
	 */
	public void setLowerBounds(double[] aLowerBounds) {
		lowerBounds = aLowerBounds;
	}

	/**
	 * @return the upperBounds
	 */
	// @EditorFactory(BoundsRatioFieldEditorFactory.class)
	// @JSON(index = 500)
	public double[] getUpperBounds() {
		return upperBounds;
	}

	/**
	 * @param aUpperBounds
	 *            the upperBounds to set
	 */
	public void setUpperBounds(double[] aUpperBounds) {
		upperBounds = aUpperBounds;
	}

	/**
	 * @return the infiniteBounds
	 */
	// @JSON(index = 600)
	public double[] getInfiniteBounds() {
		return infiniteBounds;
	}

	/**
	 * @param aInfiniteBounds
	 *            the infiniteBounds to set
	 */
	public void setInfiniteBounds(double[] aInfiniteBounds) {
		infiniteBounds = aInfiniteBounds;
	}

	/**
	 * @return the dimensions
	 */
	// @JSON(index = 300)
	public int getDimensions() {
		return dimensions;
	}

	@Override
	public String getHtmlBody(HtmlUtils aUtil) {
		String res = super.getHtmlBody(aUtil);
		if (isWorkingRatiosFilter()) {
			res += (", Ratios{");
			res += (" dim=" + dimensions);
			res += (", " + giveMeLUVectors(aUtil) + "}");
		} else {
			res += (", no ratios");
		}
		return res;
	}

	private String giveMeLUVectors(HtmlUtils util) {
		String res = "L=" + util.getColorString(Color.blue) + "[ ";
		if (lowerBounds != null && lowerBounds.length > 0) {
			res += ("(0'/-1)=" + lowerBounds[0]);
			for (int i = 0; i < lowerBounds.length - 1; ++i) {
				res += ", ";
				res += ("(" + (MinMaxBoundRanges.get3Col(i)) + "/"
						+ (MinMaxBoundRanges.get3Row(i)) + ")=" + lowerBounds[i + 1]);
			}
		}
		res += "]" + util.getColorStringClose() + ", U="
				+ util.getColorString(Color.red) + "[";
		if (upperBounds != null && upperBounds.length > 0) {
			String u = (upperBounds[0] == infiniteBounds[0]) ? "Inf"
					: (upperBounds[0] + "");
			res += ("(0'/-1)=" + u);
			for (int i = 0; i < upperBounds.length - 1; ++i) {
				res += ", ";
				u = (upperBounds[i + 1] == infiniteBounds[i + 1]) ? "Inf"
						: (upperBounds[i + 1] + "");
				res += ("(" + (MinMaxBoundRanges.get3Col(i)) + "/"
						+ (MinMaxBoundRanges.get3Row(i)) + ")=" + u);
				// res += (" of "+infiniteBounds[i]);
			}
		}
		res += "]" + util.getColorStringClose();
		return res;

	}

}
